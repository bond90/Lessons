<!doctype html>
<html lang="en">    
<head>
    <meta charset="utf-8">
    <title>Presentation </title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <!--Add support for earlier versions of Internet Explorer -->
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>

<body>
    <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">

            <!-- ALL SLIDES GO HERE -->
            <!-- Each section element contains an individual slide -->
            <section>
                <section>
                    <h1>Translation</h1><br/>Function that moves every point a constant distance in a specified direction.
                </section>
                <section>
                    A translation can also be interpreted as the addition of a constant vector to every point.
                </section>
                <section>
                    Given two vectors <span class="fragment">$v=\left[ \begin{array}{c}v_x\\v_y\\v_z\end{array}\right]$</span><span class="fragment">and $ w=\left[ \begin{array}{c}w_x\\w_y\\w_z\end{array}\right]$</span><br/>
                    <span class="fragment">The translation of vector $v$ by vector $w$ is defined by <br/> </span>
                    <span class="fragment">$v+w=$</span><span class="fragment">$\left[ \begin{array}{c}v_x\\v_y\\v_z\end{array}\right] + \left[ \begin{array}{c}w_x\\w_y\\w_z\end{array}\right] =$</span><span class="fragment">$\left[ \begin{array}{c}v_x+w_x\\v_y+w_y\\v_z+w_z\end{array}\right]$</span>
                </section>
                <section>
                    Example:<br/>
                    <span class="fragment">$v=\left[ \begin{array}{c}1\\2\\4\end{array}\right]$ and $ w=\left[ \begin{array}{c}5\\6\\7\end{array}\right]$</span><br/>
                    <span class="fragment">$v+w=$</span><span class="fragment">$\left[ \begin{array}{c}1\\2\\4\end{array}\right] + \left[ \begin{array}{c}5\\6\\7\end{array}\right] =$</span><span class="fragment">$\left[ \begin{array}{c}1+5\\2+6\\4+7\end{array}\right]=\left[ \begin{array}{c}6\\8\\11\end{array}\right]$</span>
                </section>
                <section>
                    <a href="./Translations/translations.html">Go to Translations Demo</a>
                </section>
            </section>
            <section>
                <section>
                <h1>Scaling</h1>
                Linear transformation that enlarges (increases) or shrinks (diminishes) objects by a scale factor.
                </section>
                <section>
                An object scaling can be represented using a Matrix.
                $$\left[\begin{array}{cccc}3&0&0&0\\0&2&0&0\\0&0&1&0\\0&0&0&1\\\end{array}\right]$$
                This scales "x" dimension by 3 times, "y" dimension by 2 times, and leaves "z" dimension unmodified. 
                </section>
                <section>
                    In the case of a scale factor equal for all dimensions, we're talking about "Uniform Scaling"<br/>
                    $$\left[\begin{array}{cccc}3&0&0&0\\0&3&0&0\\0&0&3&0\\0&0&0&1\\\end{array}\right]$$
                    This is an example of uniform scaling scaling the object in each dimension by factor 3.
                </section>
                <section>
                <a href="./Scaling/Scaling.html">Go to Scaling Demo</a>
                </section>
            </section>
            <section>
                <section>
                <h1>Reflection</h1>
                </section>
                <section>
                    <a href="./Reflections/reflections.html">Go to Reflections Demo</a>
                    </section>
                </section>
            </section>
            <section>
                <section>
                <h1>Rotations</h1>
                </section>
                <section>
                    Rotation: motion of a certain space that preserves at least one point.
                </section>
                <section>
                    <h3>2D Rotation</h3>
                    In two dimensions, a rotation can be represented using a 2x2 matrix:
                     $$\left[\begin{array}{cccc}cos(\theta)&-sin(\theta)\\sin(\theta)&cos(\theta)\\\end{array}\right]$$
                </section>
                <section>
                    <h3>2D Rotation</h3>
                    Here's an example: we're rotating a vector $w=\left[ \begin{array}{c}1\\0\end{array}\right]$ by 90Â°<br/>
                    <span class="fragment">$w'=\left[\begin{array}{cccc}0&1\\1&0\\\end{array}\right]\left[ \begin{array}{c}1\\0\end{array}\right]=\left[ \begin{array}{c}0\\1\end{array}\right]$</span>
                </section>
                <section>
                    <h3>3D Rotation</h3>
                </section>
                <section>
                    <h3>Euler Angles</h3>
                        Introduced by Leonhard Euler.
                        First method to describe the orientation of a rigid body.
                </section>
                <section>
                    <h3>Euler Angles</h3>
                    They describe the orientation of a reference "frame" through a series of successive rotations referred to a fixed cohordinates system, called "original frame".
                </section>
                <section>
                    <h3>Euler Angles</h3>
                    Rotations can be performed in 
                    <ul>
                        <span class="fragment"><li>12 different sequences</li></span>
                        <span class="fragment"><li>With respect to Local or World axes</li></span>
                    </ul><br/>
                        <span class="fragment">Three.js by default rotates around Local axes, and the default sequence is "XYZ". However, this sequence can be changed by simply setting an object property <br/></span>
                </section>
                <section>
                    <h3>Euler Angles</h3>
                    We can think of this sequence as a way of "nesting" axes. The first rotation changes the orientation of all the three axes, the second rotation only changes the second and the third axes, and the last one just moves the third axis in the sequence.
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    Euler Angles representation suffers from a great problem: the so-called "Gimbal Lock".<br/>
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    From Wikipedia:<br/>
                    A gimbal is a ring that is so suspended as to rotate about an axis.<br/>
                    Gimbals typically nest one within another to accommodate rotation about multiple axes.<br/>
                    <img src="http://upload.wikimedia.org/wikipedia/commons/5/5a/Gimbal_3_axes_rotation.gif"><img>
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    Gimbal lock is the loss of a degree of freedom because of the alignment of two axes.
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    Euler angles behave just like Gimbals; this means that a Gimbal Lock might occur.
                    If this happens, the system loses a degree of freedom, I.E. it is able to rotate only in two directions instead of three.
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    Rotation matrices represent a rotation around one of the axis of a coordinate system.
                    Rotations are performed counterclockwise and can be easily visualized using the right-hand rule.
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    Rotation matrices are orthogonal matrices.
                    Properties:
                    <ul>
                        <li>Determinant is 1. Orientation of the axes is not inverted</li>
                        <li></li>
                    </ul>
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    The following three matrices represent a rotation by a $\theta$ angle around the X axis, Y axis and Z axis respectively:
                    $\left[\begin{array}{cccc}1&0&0\\0&cos(\theta)&-sin(\theta)\\0&sin(\theta)&cos(\theta)\\\end{array}\right]$
                    $\left[\begin{array}{cccc}cos(\theta)&0&sin(\theta)\\0&1&0\\-sin(\theta)&0&cos(\theta)\\\end{array}\right]$
                    $\left[\begin{array}{cccc}cos(\theta)&-sin(\theta)&0\\sin(\theta)&cos(\theta)&0\\0&0&1\\\end{array}\right]$
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    Obviously, rotations can be composed.
                    Using rotation matrices, this means multiplying matrices.
                    Notice that, as matrix multiplication is generally not commutative, rotations aren't too.
                </section>
                <section>
                    Example:<br/>
                    $\left[\begin{array}{cccc}cos(\theta)&0&sin(\theta)\\0&1&0\\-sin(\theta)&0&cos(\theta)\\\end{array}\right]$
                    $\left[\begin{array}{cccc}1&0&0\\0&cos(\theta)&-sin(\theta)\\0&sin(\theta)&cos(\theta)\\\end{array}\right]$<br/>
                    Result: $\left[\begin{array}{cccc}cos(\alpha)&sin(\alpha)sin(\theta)&sin(\alpha)cos(\theta)\\0&cos(\theta)&-sin(\theta)\\-sin(\alpha)&cos(\alpha)sin(\theta)&cos(\alpha)cos(\theta)\\\end{array}\right]$<br/>
                    This matrix represents a rotation by angle $\theta$ around X axis followed by a rotation by angle $\alpha$ around Y axis.
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                </section>
                 <section>
                    <h3>Quaternions</h3>
                </section>
                <section>
                    <a href="./Rotations/rotations.html">Go to Rotations Demo</a>
                </section>
            </section>
        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
        Reveal.addEventListener( 'slidechanged', function( event ) {
            MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
        } );
    </script>

    <script>
        // Required, even if empty.
        Reveal.initialize({
        });
    </script>
</body>
</html>