<!doctype html>
<html lang="en">    
<head>
    <meta charset="utf-8">
    <title>Presentation </title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">
    <!--Add support for earlier versions of Internet Explorer -->
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true
        }
      });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
</head>

<body>
    <!-- Wrap the entire slide show in a div using the "reveal" class. -->
    <div class="reveal">
        <!-- Wrap all slides in a single "slides" class -->
        <div class="slides">

            <!-- ALL SLIDES GO HERE -->
            <!-- Each section element contains an individual slide -->
             <section>
                <h1>WebGL</h1>
                <p>JavaScript API that allows us to implement interactive 3D graphics, straight in the browser<br/>
                Web standard developed by the Khronos group <a href="http://www.khronos.org">http://www.khronos.org</a></p>
            </section>
            <section>
                <h3>WebGL</h3>
                From the website of the Khronos group:<br/>
                <i>"WebGL is a cross-platform, royalty-free web standard for a low-level 3D graphics API based on OpenGL ES 2.0, exposed through the HTML5 Canvas element as Document Object Model interfaces"</i>
            </section>
            <section>
                    <b>Canvas:</b>HTML5 element which can be used to draw graphics using scripting (usually JavaScript).<br/>
                    WebGL runs as a specific context for the canvas element.
            </section>
            <section>
                    <h3>WebGL pros</h3>
                    <ul>
                        <li>Cross-Browser</li>
                        <li>Hardware-accelerated</li>
                    </ul>
            </section>
            <section>
                <h3>Cross-Browser</h3>
                <p>
                    WebGL is supported in all the major browsers.
                </p>
                <ul>
                    <li>Chrome 9</li>
                    <li>Firefox v4+</li>
                    <li>Opera v12+</li>
                    <li>Safari 5.1</li>
                </ul>
            </section>
            <section>
                <h3>Hardware-accelerated</h3>
                WebGL draws objects on the screen directly using the GPU, thus offloading the CPU and delivering better performances.
            </section>
            <section>
                <h3>Hardware-accelerated</h3>
                The basic object is the triangle.
                Javascript is used to generate information about where and how to create triangles, and how they should look.
                These informations are then passed to the GPU, which returns a view of the scene.<br/>
                The entire process is called "Rendering Pipeline".
            </section>
            <section>
                <h3>WebGL cons</h3>
                <ul>
                    <li>Syntax quite difficult to understand.</li>
                </ul>
                <p>Solution: use of a library.</p>
            </section>
            <section>
                        <iframe id="moon" src="http://learningwebgl.com/lessons/lesson11/index.html" width="1024" height="768" style="margin:0;overflow:hidden;border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen> </iframe>
                        <script>
                        document.getElementById('moon').attributeName = 'allowfullscreen';
                        </script>
            </section>
            <section>
                <p>
                    <a href="https://gist.github.com/philogb/818017">3D model with a library (PhiloJS)</a><br/>
                    122 Lines of code.
                </p>
                <p>
                    <a href="https://github.com/gpjt/webgl-lessons/blob/master/lesson11/index.html">3D model without a library</a><br/>
                    464 lines of code.
                </p>
            </section>
            <section>
                <h1>Three.JS</h1>
                Library that simplifies the use of WebGL.
                <ul>
                    <li>Provides ready-to-use objects such as Geometries and Materials.</li>
                    <li>Provides simple methods for objects transformations (Scaling, Translating, etc.).</li>
                    <li>Takes care of the rendering part (shading), hiding most of the process to the programmer.</li>
                </ul>
            </section>
            <section>
                The library is available at <a href="http://threejs.org/">http://threejs.org/</a>.<br/>
                Documentation can be found at <a href="http://threejs.org/docs/">http://threejs.org/docs/</a>.
            </section>
            <section>
                In Three.JS, transformations of objects are described using 4x4 matrices.<br/>
                This allows us to combine different transformations in just one matrix.
            </section>
            <section>
                Three.JS offers many useful tools for linear algebra.
                <ul>
                    <li>Classes: THREE.Vector4, THREE.Matrix4, THREE.Quaternion, ecc.</li>
                    <li>Methods: vector dot and scalar product, matrix multiplication, ecc..
                </ul>
            </section>
            <section>
                <section id="translationStart">
                    <h1>Translation</h1><br/>Function that moves every point a constant distance in a specified direction.
                </section>
                <section>
                    A translation can also be interpreted as the addition of a constant vector to every point.
                </section>
                <section>
                    Given two vectors <span class="fragment">$v=\left[ \begin{array}{c}v_x\\v_y\\v_z\end{array}\right]$</span><span class="fragment">and $ w=\left[ \begin{array}{c}w_x\\w_y\\w_z\end{array}\right]$</span><br/>
                    <span class="fragment">The translation of vector $v$ by vector $w$ is defined by <br/> </span>
                    <span class="fragment">$v+w=$</span><span class="fragment">$\left[ \begin{array}{c}v_x\\v_y\\v_z\end{array}\right] + \left[ \begin{array}{c}w_x\\w_y\\w_z\end{array}\right] =$</span><span class="fragment">$\left[ \begin{array}{c}v_x+w_x\\v_y+w_y\\v_z+w_z\end{array}\right]$</span>
                </section>
                <section>
                    Example:<br/>
                    <span class="fragment">$v=\left[ \begin{array}{c}1\\2\\4\end{array}\right]$ and $ w=\left[ \begin{array}{c}5\\6\\7\end{array}\right]$</span><br/>
                    <span class="fragment">$v+w=$</span><span class="fragment">$\left[ \begin{array}{c}1\\2\\4\end{array}\right] + \left[ \begin{array}{c}5\\6\\7\end{array}\right] =$</span><span class="fragment">$\left[ \begin{array}{c}1+5\\2+6\\4+7\end{array}\right]=\left[ \begin{array}{c}6\\8\\11\end{array}\right]$</span>
                </section>
                <section>
                    <a href="./Translations/translations.html">Go to Translations Demo</a>
                </section>
            </section>
            <section>
                <section id="scalingStart">
                <h1>Scaling</h1>
                Linear transformation that enlarges (increases) or shrinks (diminishes) objects by a scale factor.
                </section>
                <section>
                An object scaling can be represented using a Matrix.
                $$\left[\begin{array}{cccc}3&0&0&0\\0&2&0&0\\0&0&1&0\\0&0&0&1\\\end{array}\right]$$
                This scales "x" dimension by 3 times, "y" dimension by 2 times, and leaves "z" dimension unmodified. 
                </section>
                <section>
                    In the case of a scale factor equal for all dimensions, we're talking about "Uniform Scaling"<br/>
                    $$\left[\begin{array}{cccc}3&0&0&0\\0&3&0&0\\0&0&3&0\\0&0&0&1\\\end{array}\right]$$
                    This is an example of uniform scaling scaling the object in each dimension by factor 3.
                </section>
                <section>
                <a href="./Scaling/Scaling.html">Go to Scaling Demo</a>
                </section>
            </section>
            <section>
                <section id="reflectionStart">
                <h1>Reflection</h1>
                Isometry with a hyperplane as a set of fixed points.
                </section>
                <section>
                <h3>Reflection</h3>
                 <ul>
                 <li>2D set: axis</li>
                 <li>3D set: plane</li>
                 </ul>
                </section>
                <section>
                <h3>Reflection</h3>
                A reflection in an hyperplane can be defined using a vector, orthogonal to the hyperplane.
                </section>
                <section>
                <h3>Reflection</h3>
                Let $w=\left[\begin{array}{cccc}w_1&w_2&\dots&w_n\end{array}\right]\in R^n$;
                the formula for the reflection in the hyperplane through the origin, orthogonal to $w$, is given by
                $$v-2\frac{v\cdot w}{w\cdot w}w=(I-2\frac{w w}{w\cdot w})v$$
                </section>
                <section>
                <h3>Reflection</h3>
                Let's break the formula apart:<br/>
                <span class="fragment"><p>$\frac{w w}{w\cdot w}$ is the matrix associated to the orthogonal projection on vector $w$. This gives us the direction orthogonal to the reflection hyperplane</p></span>
                <img src="/Content/Images/projectionVector.png" width="474px" height="392"></img>
                </section>
                <section>
                <h3>Reflection</h3>
                <p>Subtracting that projection two times from the original vector gives us the reflected vector.</p>
                <img src="/Content/Images/reflectionVector.png" width="474px" height="392"></img>
                </section>
                <section>
                <h3>Reflection</h3>
                The matrix $P=I-2\frac{w w}{w\cdot w}$ is called "HouseHolder Matrix".<br/>
                Properties:
                <ul>
                    <li>$P$ is orthogonal, with $Det(P)=-1$.</li>
                    <li>$P*P=P^2=I$. $P$ represents an involutary transformation.</li>
                    <li>$Det(P^2)=1$.
                </ul>
                </section>
                <section>
                    <a href="./Reflections/reflections.html">Go to Reflections Demo</a>
                </section>
            </section>
            <section>
                <section>
                <h1>Rotations</h1>
                </section>
                <section>
                   Rotation: progressive radial orientation to a common point that lies within the axis of the motion.
                   The axis is 90 degrees perpendicular to the plane of the motion.
                </section>
                <section>
                    <h3>2D Rotation</h3>
                    In two dimensions, a rotation can be represented using a 2x2 matrix:
                     $$\left[\begin{array}{cccc}cos(\theta)&-sin(\theta)\\sin(\theta)&cos(\theta)\\\end{array}\right]$$
                </section>
                <section>
                    <h3>2D Rotation</h3>
                    Here's an example: rotation of a vector $w=\left[ \begin{array}{c}1\\0\end{array}\right]$ by 90Â°<br/>
                    <span class="fragment">$w'=\left[\begin{array}{cccc}0&1\\1&0\\\end{array}\right]\left[ \begin{array}{c}1\\0\end{array}\right]=\left[ \begin{array}{c}0\\1\end{array}\right]$</span>
                </section>
                <section>
                    <h3>3D Rotation</h3>
                    Four methods:
                    <ul>
                        <li>Euler Angles</li>
                        <li>Rotation Matrices</li>
                        <li>Axis-angle</li>
                        <li>Quaternions</li>
                    </ul>
                </section>
                <section>
                    <h3>Euler Angles</h3>
                        Introduced by Leonhard Euler.
                        First method to describe the orientation of a rigid body.
                </section>
                <section>
                    <h3>Euler Angles</h3>
                    They describe the orientation of a reference "frame" through a series of successive rotations referred to a fixed cohordinates system, called "original frame".
                </section>
                <section>
                    <h3>Euler Angles</h3>
                    Rotations can be performed in 
                    <ul>
                        <span class="fragment"><li>12 different sequences</li></span>
                        <span class="fragment"><li>With respect to Local or World axes</li></span>
                    </ul><br/>
                        <span class="fragment">Three.js by default rotates around Local axes, and the default sequence is "XYZ". However, this sequence can be changed by simply setting an object property <br/></span>
                </section>
                <section>
                    <h3>Euler Angles</h3>
                    We can think of this sequence as a way of "nesting" axes. The first rotation changes the orientation of all the three axes, the second rotation only changes the second and the third axes, and the last one just moves the third axis in the sequence.
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    Euler Angles representation suffers from a great problem: the so-called "Gimbal Lock".<br/>
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    From Wikipedia:<br/>
                    A gimbal is a ring that is so suspended as to rotate about an axis.<br/>
                    Gimbals typically nest one within another to accommodate rotation about multiple axes.<br/>
                    <img src="http://upload.wikimedia.org/wikipedia/commons/5/5a/Gimbal_3_axes_rotation.gif"><img>
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    Gimbal lock is the loss of a degree of freedom because of the alignment of two axes.
                </section>
                <section>
                    <h3>Gimbal lock</h3>
                    Euler angles behave just like Gimbals; this means that a Gimbal Lock might occur.
                    If this happens, the system loses a degree of freedom, I.E. it is able to rotate only in two directions instead of three.
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    Rotation matrices represent a rotation around one of the axis of a coordinate system.
                    Rotations are performed counterclockwise and can be easily visualized using the right-hand rule.
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    Properties of rotation matrices:
                    <ul>
                        <li>Orthogonal</li>
                        <li>Determinant=1. Orientation of the axes is not inverted</li>
                    </ul>
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    The following three matrices represent a rotation by a $\theta$ angle around the X axis, Y axis and Z axis respectively:
                    $\left[\begin{array}{cccc}1&0&0\\0&cos(\theta)&-sin(\theta)\\0&sin(\theta)&cos(\theta)\\\end{array}\right]$
                    $\left[\begin{array}{cccc}cos(\theta)&0&sin(\theta)\\0&1&0\\-sin(\theta)&0&cos(\theta)\\\end{array}\right]$
                    $\left[\begin{array}{cccc}cos(\theta)&-sin(\theta)&0\\sin(\theta)&cos(\theta)&0\\0&0&1\\\end{array}\right]$
                </section>
                <section>
                    <h3>3D Rotation matrices</h3>
                    Composition $\rightarrow$ multiplying matrices.
                    Not commutative $\rightarrow$ order matters!
                </section>
                <section>
                    Example:<br/>
                    $\left[\begin{array}{cccc}cos(\theta)&0&sin(\theta)\\0&1&0\\-sin(\theta)&0&cos(\theta)\\\end{array}\right]$
                    $\left[\begin{array}{cccc}1&0&0\\0&cos(\theta)&-sin(\theta)\\0&sin(\theta)&cos(\theta)\\\end{array}\right]$<br/>
                    Result: $\left[\begin{array}{cccc}cos(\alpha)&sin(\alpha)sin(\theta)&sin(\alpha)cos(\theta)\\0&cos(\theta)&-sin(\theta)\\-sin(\alpha)&cos(\alpha)sin(\theta)&cos(\alpha)cos(\theta)\\\end{array}\right]$<br/>
                    This matrix represents a rotation by angle $\theta$ around X axis followed by a rotation by angle $\alpha$ around Y axis.
                </section>
                <section>
                    <h3>Axis-Angle</h3>
                    Derives from Euler's rotation theorem:<br/>
                    <i>"When a sphere is moved around its centre it is always possible to find a diameter whose direction in the displaced position is the same as in the initial position."</i>
                </section>
                <section>
                    <h3>Axis-Angle</h3>
                    Parameterizes rotation using two values:
                    <ul>
                        <li>A unit (normalized) vector describing the direction of the axis of rotation</li>
                        <li>An angle $\theta$ describing the magnitude of the rotation</li>
                    </ul>
                    Rotation occurs following the right-hand rule.
                </section>
                <section id="QuaternionStart">
                    <h3>Quaternions</h3>
                    <p>Set that extends real numbers.<br/>
                    Composed by object of this kind:
                    $a + ib + jc + kd$, with $i^2=j^2=k^2=ijk=-1$
                    </p>
                </section>
                <section>
                    <h3>Quaternions</h3>
                    Together with sum and scalar real product, they form a real vector space of size 4.
                </section>
                <section>
                    <h3>Quaternions</h3>
                    Given a unit vector $w=\left[\begin{array}w_x\\w_y\\w_z\end{array}\right]$ representing the rotation axis and an angle $\theta$,
                    we can write the corresponding unit quaternion like this:
                    $$Z=\cos\left(\frac{\theta}{2}\right)+\sin\left(\frac{\theta}{2}\right)(iw_x+jw_y+kw_z)$$
                    The corresponding rotation of vector $v$ using quaternion $Z$ is: $ZV\overline{Z}$
                </section>
                <section>
                    <h3>Quaternions</h3>
                    Pros:
                    <ul>
                        <li>Easy to compose: $n$ subsequent rotations correspond to a single one using the product of the $n$ quaternions.</li>
                        <li>Numerically stabler than matrices</li>
                    </ul>
                </section>
                <section>
                    <a href="./Rotations/rotations.html">Go to Rotations Demo</a>
                </section>
            </section>
        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
        Reveal.addEventListener( 'slidechanged', function( event ) {
            MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
        } );
    </script>

    <script>
        // Required, even if empty.
        Reveal.initialize({
        });
    </script>
</body>
</html>